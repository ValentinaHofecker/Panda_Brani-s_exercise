
import math


class SegmentationTree():
    def __init__(self, input_list):
        self._input_list = input_list [:] # copy of input list
        self._init_tree()
        self._is_propogated = True

    def _init_tree(self):
        ### CREATE SEGMENTATION TREE INFRASTRUCTURE ###

        ### lenght of list
        self._n = len(self._input_list)

        ### calc. of height
        height = math.ceil(math.log(self._n, 2)) # ciel = aufrunden!

        ### calc. number of nodes
        n_nodes = 2 * (2 ** height) - 1

        ### create empty seg_tree_
        self._seg_tree = [None] * n_nodes

        ### propogate (fill) seg_tree_
        arr_left = 0 # leftest element of array = index 0
        arr_right = self._n - 1 # rightest element of array = index = lenght of array -1
        seg_node_index = 0 # root of seg tree = index 0
        self._propogate(arr_left, arr_right, seg_node_index)

    def _propogate(self, arr_left, arr_right, seg_node_index): # arr_ = original arry
        # recursive implementation
        # Base Cases needed
        if arr_right < arr_left: # went too far
            return
        if arr_left == arr_right: # when seg tree index = array list index
            # grab value from input list
            value = self._input_list[arr_left] # or arr_right since they'd be the same in this case
            # assign value into seg_tree at correct index
            self._seg_tree[seg_node_index] = value
            return

        # recursive call = we're at a parent node and need to split into 2
        midpoint = (arr_left + arr_right) // 2 # floor division, will put extra on left side

        # left side
        left_seg_node_index = seg_node_index * 2 + 1
        left_node_array_left = arr_left
        left_node_arr_right = midpoint
        self._propogate(left_node_array_left, left_node_arr_right, left_seg_node_index)

        # right side
        right_seg_node_index = seg_node_index * 2 + 2
        right_node_array_left = midpoint + 1 # might go over (base case for that)
        right_node_arr_right = arr_right
        self._propogate(right_node_array_left, right_node_arr_right, right_seg_node_index)

        # handle the parent
        left_val = self._seg_tree[left_seg_node_index]
        right_val = self._seg_tree[right_seg_node_index]
        self._seg_tree[seg_node_index] = left_val + right_val # aggregation = sum

### HOW TO QUERY??? -> search tree for specific range and return value

    def query(self, query_left, query_right): # interface: no underscore cause we want to expose this to the users
        arr_left = 0  # leftest element of array = index 0
        arr_right = self._n - 1  # rightest element of array = index = lenght of array -1
        seg_node_index = 0  # root of seg tree = index 0

        # propogate if internal list changed
        if not self._is_propogated:
            self._propogate(arr_left, arr_right, seg_node_index) # if it isn't propogated it will propogate and THEN start query

        # start searching from root node
        return self._query_helper(query_left, query_right, arr_left, arr_right, seg_node_index)

    def _query_helper(self, query_left, query_right, arr_left, arr_right, seg_node_index): # underscore so its only sichtbar for programmers
        # recursive implementation
        # Base Cases needed

        if arr_right < arr_left: # went too far
            return 0 # return Zero so that we can continue

        if query_right < arr_left or arr_right < query_left: # node is outside of query range
            return 0

        if query_left <= arr_left and arr_right <= query_right: # current node completely within query range
            return self._seg_tree[seg_node_index] # we found what we need, return it



        # recursive call = we're at a parent that is partially covering query
        midpoint = (arr_left + arr_right) // 2 # floor division, will put extra on left side

        # left side
        left_seg_node_index = seg_node_index * 2 + 1
        left_node_array_left = arr_left
        left_node_arr_right = midpoint
        left_val = self._query_helper(query_left, query_right, left_node_array_left, left_node_arr_right, left_seg_node_index)

        # right side
        right_seg_node_index = seg_node_index * 2 + 2
        right_node_array_left = midpoint + 1
        right_node_arr_right = arr_right
        right_val = self._query_helper(query_left, query_right,right_node_array_left, right_node_arr_right, right_seg_node_index)

        # handle the parent
        return left_val + right_val # aggregation is sum



### UPDATE FUNCTION

    def update(self, arr_index, new_value): # lazy update (not propogating until we're ready to do so)
        old_value = self._input_list[arr_index]
        if old_value != new_value:
            self._input_list[arr_index] = new_value
            self._is_propogated = False # so that we can do a lot of changes before propogation



### TEST ###

nums = [3, 4, 10, 2, 7]
st = SegmentationTree(nums)
print(st._seg_tree)
assert st.query(1,3) == 16
st.update(1,2)
assert st.query(1,3) == 14



